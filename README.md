# Задание 3. Найдите ошибки

## Исправленные ошибки:
### server.ts
1. VS Code подсветил ошибку на `textDocumentSync: 'always'`, посмотрел пример использования onInitialize в доке, сделал как там.
2. Когда внедрил всю нужную в задании функциональность в окно превью интерфейса, пришло время заниматься внедрением линтера. Ошибки в файле не отображались изначально, хотя код для валидации файла был написан. Значит, где-то в расширении была ошибка. Почитав в документации, понял, что за такие вещи как валидация документа и сбор ошибок отвечает т.н. Language Server, который потом отправляет данные о тех самых ошибках на Language Client. Начал дебажить, обнаружил что метода onInitialize сервера просто не вызывается, значит, подумал я, ошибка в клиенте, т.к. именно он является входной точкой расширения и сервер запускается после запуска клиента. Только потом я посмотрел, что по умолчанию в `package.json` работа линтера отключена, включил. Language Server запустился, но ошибки всё равно не отображались. Через дебагинг понял,

### json-to-ast.d.ts
1. В файле `server.ts` VS Code подсветил ошибку на `loc: property.key.loc` с сообщением о том что поля loc у типа AstIdentifier нет. Добавил тип.

### extension.ts
1. Превью начало открываться, но выводилась единственная надпись - `{{content}}`. Посмотрев как работает расширение, я обнаружил функцию, которая должна заменять `{{content}}` на сгенерированную из JSON HTML-разметку. Понял, что функция просто пропускает `{{content}}` из-за неверного регулярного выражения (`/{{\s+(\w+)\s+}}/g`). Исправил регулярное выражение на `/{{\s?(\w+)\s?}}/g`.
2. После исправления надпись `{{content}}` исчезла, но на этот разщ превью стало просто пустым. Я открыл Developer Tools для WebView, обнаружил что html-разметка вставляется в страницу корректно, но при этом не подключает css-файл, из-за чего мы и получаем блоки с нулевой высотой и с виду пустую страницу. Почитал в документации про конфигурацию WebView, после нескольких попыток решить проблему (в основном эксперементировал с конфигурацией и получением адреса стилей, которые WebView съел бы) написал-таки функцию  `getStylesPath` и код, который заменяет `{{stylesPath}}` на корректный для WebView URL стилей, получаемый из этой функции.

### index.html
1. Заменил `<link rel="stylesheet" href="/preview/style.css" />` на `<link rel="stylesheet" href="{{stylesLink}}" />`, чтобы динамически вставлять в разметку путь к стилям (см. `extension.ts`).

### style.css
1. Через Developer Tools увидел, что ни одному из блоков по умолчанию не присваивается класс div, а в css-файл селекторы обращались именно к `.div`, из-за чего блоки не отображались. Поменял селекторы на `div`.
2. Немного изменил стили, чтобы удобно было работать с расширением на маленьких экранах (столкнулся с проблемой работая на ноутбуке с диагональю 13")
3. Кардинально изменил файл, чтобы внедрить блок выбора режима превью и сбросить его стили так, чтобы они не смешивались со стилями, собственно, превью.


## Внедренные возможности:
### Переключение между режимами отображения контента
Во время разработки фичи всё время просматривал документацию Webview API. 

Пробовал реализовать сначала одними средствами JS в WebView. 

Потом надеялся что смогу реализовать чтение state'а webView из кода расширения - не получилось. 

В процессе открыл для себя возможность обменя сообщениями между WebView и расширением, но, внедрив, столкнулся с такой проблемой: режимы переключались, но если в json-файле происходили изменения, вызывалась функция updateContent и режим сбрасывался на дефолтный.

После нескольких попыток что-то с этим сделать обнаружил что у расширения можно использовать собственное хранилище, что подходило для решения моей проблемы. 

Тогда я скомбинировал два подхода: по переключению режима в интерфейсе, я отправляю расширению сообщение с идентификатором режима. Когда оно приходит, я сохраняю этот идентификатор в workspaceState, затем вызываю функцию updateContent, в которой идентификатор режима всегда парсится из workspaceState. Соответственно, при обновлении кода функция тоже будет исполняться, зная про то, какой режим превью сейчас активирован.

### Проверка блоков линтером из задания 2
Сначала наладил работу линтера, который уже шел в репозитории, исправив ошибки, мешающие его работе. Вообще изначально я интегрировал линтер таким способом: сначала читал содержимое файла и строку с этим содержимым передавал в функцию eval, после исполнения кода в глоб. области видимости создавалась функция lint, которую, в принципе, можно было использовать. Но мне сразу такое решение показалось каким-то неэлегантным, как минимум. Я решил, что нужно подключать линтер как библиотеку, т.е. импортировать отдельно функцию lint() из файла и потом использовать её в коде. Здесь я столкнулся с проблемой импорта, из файла будто не было экспорта функции. Пробовал решить её, создавая для линтера .d.ts файл - не помогало. После этого я решил попробовать изменить что-то в собственно коде линтера. Начал искать информацию по поводу разработки JS-библиотек и их сборки для использования в других проектах. Таким образом поменял инструмент и конфигурацию сборки в линтере. Из нового файла линтера уже получилось нормально вытащить функцию, но только через require, а не import (Думаю, потому что в кач-ве модульной системы в Rollup у меня выбрана cjs). После настройки работы обнаружил что ошибки в документе подсвечиваются со сдвигом примерно на одну строку вниз. Подумал, что это из-за того, что я два раза конвертировал значения позиций - сначала в offset, а потом в Position, т.к. второе задание не требовало поля offset в данных о расположении ошибки. Я вернулся в код линтера, добавил в ошибки поля offset, после чего в расширении требовалось делать только одну конвертацию - в Position. После этого ошибочные места в файле стали подсвечиваться корректно. После этого добавил дополнительные настройки для типов сообщений линтера блоков (что тоже доставило некоторые неудобства, т.к. ключи конфигураций и коды ошибок имеют разный формат записи, и второй череват неудобствами за счет содержания в нём точек).